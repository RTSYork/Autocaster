//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Mon Sep  2 14:51:40 BST 2013
//
// Method conflict info:
// Method: vsync
// Conflict-free: hsync, vde, rgb, detected
// Conflicts: vsync
//
// Method: hsync
// Conflict-free: vsync, vde, rgb, detected
// Conflicts: hsync
//
// Method: vde
// Conflict-free: vsync, hsync, rgb, detected
// Conflicts: vde
//
// Method: rgb
// Conflict-free: vsync, hsync, vde, detected
// Conflicts: rgb
//
// Method: detected
// Conflict-free: vsync, hsync, vde, rgb, detected
//
//
// Ports:
// Name                         I/O  size props
// detected                       O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// rgb_pixel                      I    24
// vsync                          I     1
// hsync                          I     1
// vde                            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkScreen(CLK,
		RST_N,

		vsync,

		hsync,

		vde,

		rgb_pixel,

		detected);
  parameter [1 : 0] numPos = 2'b0;
  parameter [10 : 0] xPos1 = 11'b0;
  parameter [9 : 0] yPos1 = 10'b0;
  parameter [23 : 0] pixel1 = 24'b0;
  parameter [10 : 0] xPos2 = 11'b0;
  parameter [9 : 0] yPos2 = 10'b0;
  parameter [23 : 0] pixel2 = 24'b0;
  parameter [10 : 0] xPos3 = 11'b0;
  parameter [9 : 0] yPos3 = 10'b0;
  parameter [23 : 0] pixel3 = 24'b0;
  input  CLK;
  input  RST_N;

  // action method vsync
  input  vsync;

  // action method hsync
  input  hsync;

  // action method vde
  input  vde;

  // action method rgb
  input  [23 : 0] rgb_pixel;

  // value method detected
  output detected;

  // signals for module outputs
  wire detected;

  // register currentDetected
  reg currentDetected;
  wire currentDetected$D_IN, currentDetected$EN;

  // register lastDetected
  reg lastDetected;
  wire lastDetected$D_IN, lastDetected$EN;

  // register pointDetected
  reg pointDetected;
  wire pointDetected$D_IN, pointDetected$EN;

  // register pointDetected_1
  reg pointDetected_1;
  wire pointDetected_1$D_IN, pointDetected_1$EN;

  // register pointDetected_2
  reg pointDetected_2;
  wire pointDetected_2$D_IN, pointDetected_2$EN;

  // register x
  reg [10 : 0] x;
  wire [10 : 0] x$D_IN;
  wire x$EN;

  // register y
  reg [9 : 0] y;
  wire [9 : 0] y$D_IN;
  wire y$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_new_line,
       WILL_FIRE_RL_new_pixel,
       WILL_FIRE_RL_point1,
       WILL_FIRE_RL_point2,
       WILL_FIRE_RL_point3;

  // inputs to muxes for submodule ports
  wire [10 : 0] MUX_x$write_1__VAL_1;
  wire [9 : 0] MUX_y$write_1__VAL_1;
  wire MUX_pointDetected$write_1__VAL_1,
       MUX_pointDetected_1$write_1__VAL_1,
       MUX_pointDetected_2$write_1__VAL_1,
       MUX_x$write_1__SEL_2;

  // remaining internal signals
  wire x_1_EQ_xPos1_7_AND_y_5_EQ_yPos1_8_9_AND_NOT_vs_ETC___d30,
       x_1_EQ_xPos2_1_AND_y_5_EQ_yPos2_2_3_AND_NOT_vs_ETC___d64,
       x_1_EQ_xPos3_2_AND_y_5_EQ_yPos3_3_4_AND_NOT_vs_ETC___d95;

  // value method detected
  assign detected = currentDetected && lastDetected ;

  // rule RL_point1
  assign WILL_FIRE_RL_point1 =
	     x_1_EQ_xPos1_7_AND_y_5_EQ_yPos1_8_9_AND_NOT_vs_ETC___d30 &&
	     numPos != 2'd0 ;

  // rule RL_point2
  assign WILL_FIRE_RL_point2 =
	     x_1_EQ_xPos2_1_AND_y_5_EQ_yPos2_2_3_AND_NOT_vs_ETC___d64 &&
	     numPos > 2'd1 ;

  // rule RL_point3
  assign WILL_FIRE_RL_point3 =
	     x_1_EQ_xPos3_2_AND_y_5_EQ_yPos3_3_4_AND_NOT_vs_ETC___d95 &&
	     numPos == 2'd3 ;

  // rule RL_new_line
  assign WILL_FIRE_RL_new_line = hsync && !vsync && x != 11'd0 ;

  // rule RL_new_pixel
  assign WILL_FIRE_RL_new_pixel = vde && !hsync && !vsync ;

  // inputs to muxes for submodule ports
  assign MUX_x$write_1__SEL_2 = WILL_FIRE_RL_new_line || vsync ;
  assign MUX_pointDetected$write_1__VAL_1 =
	     ((pixel1[23:16] <= rgb_pixel[23:16]) ?
		rgb_pixel[23:16] - pixel1[23:16] < 8'd8 :
		pixel1[23:16] - rgb_pixel[23:16] < 8'd8) &&
	     ((pixel1[15:8] <= rgb_pixel[15:8]) ?
		rgb_pixel[15:8] - pixel1[15:8] < 8'd8 :
		pixel1[15:8] - rgb_pixel[15:8] < 8'd8) &&
	     ((pixel1[7:0] <= rgb_pixel[7:0]) ?
		rgb_pixel[7:0] - pixel1[7:0] < 8'd8 :
		pixel1[7:0] - rgb_pixel[7:0] < 8'd8) ;
  assign MUX_pointDetected_1$write_1__VAL_1 =
	     ((pixel2[23:16] <= rgb_pixel[23:16]) ?
		rgb_pixel[23:16] - pixel2[23:16] < 8'd8 :
		pixel2[23:16] - rgb_pixel[23:16] < 8'd8) &&
	     ((pixel2[15:8] <= rgb_pixel[15:8]) ?
		rgb_pixel[15:8] - pixel2[15:8] < 8'd8 :
		pixel2[15:8] - rgb_pixel[15:8] < 8'd8) &&
	     ((pixel2[7:0] <= rgb_pixel[7:0]) ?
		rgb_pixel[7:0] - pixel2[7:0] < 8'd8 :
		pixel2[7:0] - rgb_pixel[7:0] < 8'd8) ;
  assign MUX_pointDetected_2$write_1__VAL_1 =
	     ((pixel3[23:16] <= rgb_pixel[23:16]) ?
		rgb_pixel[23:16] - pixel3[23:16] < 8'd8 :
		pixel3[23:16] - rgb_pixel[23:16] < 8'd8) &&
	     ((pixel3[15:8] <= rgb_pixel[15:8]) ?
		rgb_pixel[15:8] - pixel3[15:8] < 8'd8 :
		pixel3[15:8] - rgb_pixel[15:8] < 8'd8) &&
	     ((pixel3[7:0] <= rgb_pixel[7:0]) ?
		rgb_pixel[7:0] - pixel3[7:0] < 8'd8 :
		pixel3[7:0] - rgb_pixel[7:0] < 8'd8) ;
  assign MUX_x$write_1__VAL_1 = x + 11'd1 ;
  assign MUX_y$write_1__VAL_1 = y + 10'd1 ;

  // register currentDetected
  assign currentDetected$D_IN =
	     pointDetected && pointDetected_1 && pointDetected_2 ;
  assign currentDetected$EN = vsync ;

  // register lastDetected
  assign lastDetected$D_IN = currentDetected ;
  assign lastDetected$EN = vsync ;

  // register pointDetected
  assign pointDetected$D_IN =
	     !WILL_FIRE_RL_point1 || MUX_pointDetected$write_1__VAL_1 ;
  assign pointDetected$EN = WILL_FIRE_RL_point1 || numPos == 2'd0 ;

  // register pointDetected_1
  assign pointDetected_1$D_IN =
	     !WILL_FIRE_RL_point2 || MUX_pointDetected_1$write_1__VAL_1 ;
  assign pointDetected_1$EN = WILL_FIRE_RL_point2 || numPos < 2'd2 ;

  // register pointDetected_2
  assign pointDetected_2$D_IN =
	     !WILL_FIRE_RL_point3 || MUX_pointDetected_2$write_1__VAL_1 ;
  assign pointDetected_2$EN = WILL_FIRE_RL_point3 || numPos != 2'd3 ;

  // register x
  assign x$D_IN = WILL_FIRE_RL_new_pixel ? MUX_x$write_1__VAL_1 : 11'd0 ;
  assign x$EN = WILL_FIRE_RL_new_pixel || WILL_FIRE_RL_new_line || vsync ;

  // register y
  assign y$D_IN = WILL_FIRE_RL_new_line ? MUX_y$write_1__VAL_1 : 10'd0 ;
  assign y$EN = MUX_x$write_1__SEL_2 ;

  // remaining internal signals
  assign x_1_EQ_xPos1_7_AND_y_5_EQ_yPos1_8_9_AND_NOT_vs_ETC___d30 =
	     x == xPos1 && y == yPos1 && !vsync ;
  assign x_1_EQ_xPos2_1_AND_y_5_EQ_yPos2_2_3_AND_NOT_vs_ETC___d64 =
	     x == xPos2 && y == yPos2 && !vsync ;
  assign x_1_EQ_xPos3_2_AND_y_5_EQ_yPos3_3_4_AND_NOT_vs_ETC___d95 =
	     x == xPos3 && y == yPos3 && !vsync ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        currentDetected <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lastDetected <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pointDetected <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pointDetected_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	pointDetected_2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	x <= `BSV_ASSIGNMENT_DELAY 11'd0;
	y <= `BSV_ASSIGNMENT_DELAY 10'd0;
      end
    else
      begin
        if (currentDetected$EN)
	  currentDetected <= `BSV_ASSIGNMENT_DELAY currentDetected$D_IN;
	if (lastDetected$EN)
	  lastDetected <= `BSV_ASSIGNMENT_DELAY lastDetected$D_IN;
	if (pointDetected$EN)
	  pointDetected <= `BSV_ASSIGNMENT_DELAY pointDetected$D_IN;
	if (pointDetected_1$EN)
	  pointDetected_1 <= `BSV_ASSIGNMENT_DELAY pointDetected_1$D_IN;
	if (pointDetected_2$EN)
	  pointDetected_2 <= `BSV_ASSIGNMENT_DELAY pointDetected_2$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    currentDetected = 1'h0;
    lastDetected = 1'h0;
    pointDetected = 1'h0;
    pointDetected_1 = 1'h0;
    pointDetected_2 = 1'h0;
    x = 11'h2AA;
    y = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkScreen

