//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Thu Aug 29 17:25:31 BST 2013
//
// Method conflict info:
// Method: vsync
// Conflict-free: fret, strumTime, strum
// Conflicts: vsync
//
// Method: fret
// Conflict-free: vsync, strumTime, strum
// Conflicts: fret
//
// Method: strumTime
// Conflict-free: vsync, fret, strum
// Conflicts: strumTime
//
// Method: strum
// Conflict-free: vsync, fret, strumTime, strum
//
//
// Ports:
// Name                         I/O  size props
// strum                          O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fret_g                         I     1
// fret_r                         I     1
// fret_y                         I     1
// fret_b                         I     1
// fret_o                         I     1
// strumTime_in                   I     4
// vsync                          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkStrum(CLK,
	       RST_N,

	       vsync,

	       fret_g,
	       fret_r,
	       fret_y,
	       fret_b,
	       fret_o,

	       strumTime_in,

	       strum);
  input  CLK;
  input  RST_N;

  // action method vsync
  input  vsync;

  // action method fret
  input  fret_g;
  input  fret_r;
  input  fret_y;
  input  fret_b;
  input  fret_o;

  // action method strumTime
  input  [3 : 0] strumTime_in;

  // value method strum
  output strum;

  // signals for module outputs
  wire strum;

  // register fretPressed
  reg fretPressed;
  wire fretPressed$D_IN, fretPressed$EN;

  // register fretsDiff
  reg fretsDiff;
  wire fretsDiff$D_IN, fretsDiff$EN;

  // register lastFrets
  reg [4 : 0] lastFrets;
  wire [4 : 0] lastFrets$D_IN;
  wire lastFrets$EN;

  // register strumCount
  reg [3 : 0] strumCount;
  reg [3 : 0] strumCount$D_IN;
  wire strumCount$EN;

  // register strumOutput
  reg strumOutput;
  wire strumOutput$D_IN, strumOutput$EN;

  // register vsync_pulse2
  reg vsync_pulse2;
  wire vsync_pulse2$D_IN, vsync_pulse2$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_strum_off,
       WILL_FIRE_RL_strum_on,
       WILL_FIRE_RL_strum_reset;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_strumCount$write_1__VAL_1, MUX_strumCount$write_1__VAL_2;
  wire MUX_strumOutput$write_1__SEL_1;

  // remaining internal signals
  wire [4 : 0] x__h610, x__h622, x__h645;

  // value method strum
  assign strum = strumOutput ;

  // rule RL_strum_on
  assign WILL_FIRE_RL_strum_on =
	     vsync && fretPressed && strumCount < strumTime_in ;

  // rule RL_strum_off
  assign WILL_FIRE_RL_strum_off =
	     vsync && fretPressed && strumCount == strumTime_in ;

  // rule RL_strum_reset
  assign WILL_FIRE_RL_strum_reset =
	     !vsync && vsync_pulse2 && (!fretPressed || fretsDiff) &&
	     strumCount != 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_strumOutput$write_1__SEL_1 =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ;
  assign MUX_strumCount$write_1__VAL_1 = strumCount + 4'd1 ;
  assign MUX_strumCount$write_1__VAL_2 = strumTime_in + 4'd1 ;

  // register fretPressed
  assign fretPressed$D_IN = x__h645 != 5'd0 ;
  assign fretPressed$EN = vsync ;

  // register fretsDiff
  assign fretsDiff$D_IN = x__h610 != 5'd0 ;
  assign fretsDiff$EN = vsync ;

  // register lastFrets
  assign lastFrets$D_IN = x__h645 ;
  assign lastFrets$EN = vsync ;

  // register strumCount
  always@(WILL_FIRE_RL_strum_on or
	  MUX_strumCount$write_1__VAL_1 or
	  WILL_FIRE_RL_strum_off or
	  MUX_strumCount$write_1__VAL_2 or WILL_FIRE_RL_strum_reset)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_strum_on: strumCount$D_IN = MUX_strumCount$write_1__VAL_1;
      WILL_FIRE_RL_strum_off: strumCount$D_IN = MUX_strumCount$write_1__VAL_2;
      WILL_FIRE_RL_strum_reset: strumCount$D_IN = 4'd0;
      default: strumCount$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign strumCount$EN =
	     WILL_FIRE_RL_strum_on || WILL_FIRE_RL_strum_off ||
	     WILL_FIRE_RL_strum_reset ;

  // register strumOutput
  assign strumOutput$D_IN = !MUX_strumOutput$write_1__SEL_1 ;
  assign strumOutput$EN =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ||
	     WILL_FIRE_RL_strum_on ;

  // register vsync_pulse2
  assign vsync_pulse2$D_IN = !WILL_FIRE_RL_strum_reset ;
  assign vsync_pulse2$EN = WILL_FIRE_RL_strum_reset || vsync ;

  // remaining internal signals
  assign x__h610 = x__h622 & x__h645 ;
  assign x__h622 = ~lastFrets ;
  assign x__h645 = { fret_g, fret_r, fret_y, fret_b, fret_o } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        fretPressed <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fretsDiff <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lastFrets <= `BSV_ASSIGNMENT_DELAY 5'd0;
	strumCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	strumOutput <= `BSV_ASSIGNMENT_DELAY 1'd0;
	vsync_pulse2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (fretPressed$EN)
	  fretPressed <= `BSV_ASSIGNMENT_DELAY fretPressed$D_IN;
	if (fretsDiff$EN) fretsDiff <= `BSV_ASSIGNMENT_DELAY fretsDiff$D_IN;
	if (lastFrets$EN) lastFrets <= `BSV_ASSIGNMENT_DELAY lastFrets$D_IN;
	if (strumCount$EN)
	  strumCount <= `BSV_ASSIGNMENT_DELAY strumCount$D_IN;
	if (strumOutput$EN)
	  strumOutput <= `BSV_ASSIGNMENT_DELAY strumOutput$D_IN;
	if (vsync_pulse2$EN)
	  vsync_pulse2 <= `BSV_ASSIGNMENT_DELAY vsync_pulse2$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fretPressed = 1'h0;
    fretsDiff = 1'h0;
    lastFrets = 5'h0A;
    strumCount = 4'hA;
    strumOutput = 1'h0;
    vsync_pulse2 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkStrum

