//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Mon Apr  1 19:02:18 BST 2013
//
// Method conflict info:
// Method: vsync
// Conflict-free: strumTime, strum
// Sequenced before (restricted): fret
// Conflicts: vsync
//
// Method: fret
// Sequenced before (restricted): fret
// Sequenced after (restricted): vsync, strumTime, strum
//
// Method: strumTime
// Conflict-free: vsync, strum
// Sequenced before (restricted): fret
// Conflicts: strumTime
//
// Method: strum
// Conflict-free: vsync, strumTime, strum
// Sequenced before (restricted): fret
//
//
// Ports:
// Name                         I/O  size props
// strum                          O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fret_g                         I     1 reg
// fret_r                         I     1 reg
// fret_y                         I     1 reg
// fret_b                         I     1 reg
// fret_o                         I     1 reg
// strumTime_in                   I     4
// vsync                          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkStrum(CLK,
	       RST_N,

	       vsync,

	       fret_g,
	       fret_r,
	       fret_y,
	       fret_b,
	       fret_o,

	       strumTime_in,

	       strum);
  input  CLK;
  input  RST_N;

  // action method vsync
  input  vsync;

  // action method fret
  input  fret_g;
  input  fret_r;
  input  fret_y;
  input  fret_b;
  input  fret_o;

  // action method strumTime
  input  [3 : 0] strumTime_in;

  // value method strum
  output strum;

  // signals for module outputs
  wire strum;

  // register fretPressed
  reg fretPressed;
  wire fretPressed$D_IN, fretPressed$EN;

  // register frets
  reg [4 : 0] frets;
  wire [4 : 0] frets$D_IN;
  wire frets$EN;

  // register strumCount
  reg [3 : 0] strumCount;
  reg [3 : 0] strumCount$D_IN;
  wire strumCount$EN;

  // register strumOutput
  reg strumOutput;
  wire strumOutput$D_IN, strumOutput$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_strum_off,
       WILL_FIRE_RL_strum_on,
       WILL_FIRE_RL_strum_reset;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_strumCount$write_1__VAL_1, MUX_strumCount$write_1__VAL_2;
  wire MUX_strumOutput$write_1__SEL_1;

  // value method strum
  assign strum = strumOutput ;

  // rule RL_strum_on
  assign WILL_FIRE_RL_strum_on =
	     vsync && fretPressed && strumCount < strumTime_in ;

  // rule RL_strum_off
  assign WILL_FIRE_RL_strum_off =
	     vsync && fretPressed && strumCount == strumTime_in ;

  // rule RL_strum_reset
  assign WILL_FIRE_RL_strum_reset =
	     vsync && !fretPressed && strumCount != 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_strumOutput$write_1__SEL_1 =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ;
  assign MUX_strumCount$write_1__VAL_1 = strumCount + 4'd1 ;
  assign MUX_strumCount$write_1__VAL_2 = strumTime_in + 4'd1 ;

  // register fretPressed
  assign fretPressed$D_IN = frets != 5'd0 ;
  assign fretPressed$EN = vsync ;

  // register frets
  assign frets$D_IN = { fret_g, fret_r, fret_y, fret_b, fret_o } ;
  assign frets$EN = 1'd1 ;

  // register strumCount
  always@(WILL_FIRE_RL_strum_on or
	  MUX_strumCount$write_1__VAL_1 or
	  WILL_FIRE_RL_strum_off or
	  MUX_strumCount$write_1__VAL_2 or WILL_FIRE_RL_strum_reset)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_strum_on: strumCount$D_IN = MUX_strumCount$write_1__VAL_1;
      WILL_FIRE_RL_strum_off: strumCount$D_IN = MUX_strumCount$write_1__VAL_2;
      WILL_FIRE_RL_strum_reset: strumCount$D_IN = 4'd0;
      default: strumCount$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign strumCount$EN =
	     WILL_FIRE_RL_strum_on || WILL_FIRE_RL_strum_off ||
	     WILL_FIRE_RL_strum_reset ;

  // register strumOutput
  assign strumOutput$D_IN = !MUX_strumOutput$write_1__SEL_1 ;
  assign strumOutput$EN =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ||
	     WILL_FIRE_RL_strum_on ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        fretPressed <= `BSV_ASSIGNMENT_DELAY 1'd0;
	frets <= `BSV_ASSIGNMENT_DELAY 5'd0;
	strumCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	strumOutput <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (fretPressed$EN)
	  fretPressed <= `BSV_ASSIGNMENT_DELAY fretPressed$D_IN;
	if (frets$EN) frets <= `BSV_ASSIGNMENT_DELAY frets$D_IN;
	if (strumCount$EN)
	  strumCount <= `BSV_ASSIGNMENT_DELAY strumCount$D_IN;
	if (strumOutput$EN)
	  strumOutput <= `BSV_ASSIGNMENT_DELAY strumOutput$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fretPressed = 1'h0;
    frets = 5'h0A;
    strumCount = 4'hA;
    strumOutput = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkStrum

