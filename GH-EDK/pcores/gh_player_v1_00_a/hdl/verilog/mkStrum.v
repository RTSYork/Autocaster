//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Fri Aug 23 15:04:57 BST 2013
//
// Method conflict info:
// Method: vsync
// Conflict-free: fret, strumTime, strum
// Conflicts: vsync
//
// Method: fret
// Conflict-free: vsync, strumTime, strum
// Conflicts: fret
//
// Method: strumTime
// Conflict-free: vsync, fret, strum
// Conflicts: strumTime
//
// Method: strum
// Conflict-free: vsync, fret, strumTime, strum
//
//
// Ports:
// Name                         I/O  size props
// strum                          O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// fret_g                         I     1
// fret_r                         I     1
// fret_y                         I     1
// fret_b                         I     1
// fret_o                         I     1
// strumTime_in                   I     4
// vsync                          I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkStrum(CLK,
	       RST_N,

	       vsync,

	       fret_g,
	       fret_r,
	       fret_y,
	       fret_b,
	       fret_o,

	       strumTime_in,

	       strum);
  input  CLK;
  input  RST_N;

  // action method vsync
  input  vsync;

  // action method fret
  input  fret_g;
  input  fret_r;
  input  fret_y;
  input  fret_b;
  input  fret_o;

  // action method strumTime
  input  [3 : 0] strumTime_in;

  // value method strum
  output strum;

  // signals for module outputs
  wire strum;

  // register fretPressed
  reg fretPressed;
  wire fretPressed$D_IN, fretPressed$EN;

  // register fretsDiff
  reg fretsDiff;
  wire fretsDiff$D_IN, fretsDiff$EN;

  // register lastFrets
  reg [4 : 0] lastFrets;
  wire [4 : 0] lastFrets$D_IN;
  wire lastFrets$EN;

  // register strumCount
  reg [3 : 0] strumCount;
  wire [3 : 0] strumCount$D_IN;
  wire strumCount$EN;

  // register strumOutput
  reg strumOutput;
  wire strumOutput$D_IN, strumOutput$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_strum_off, WILL_FIRE_RL_strum_reset;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_strumCount$write_1__VAL_1;
  wire MUX_strumCount$write_1__SEL_2;

  // remaining internal signals
  wire [4 : 0] x__h569;
  wire vsync_pulse_whas_AND_fretPressed_1_2_AND_frets_ETC___d18;

  // value method strum
  assign strum = strumOutput ;

  // rule RL_strum_off
  assign WILL_FIRE_RL_strum_off =
	     vsync && fretPressed && strumCount == strumTime_in ;

  // rule RL_strum_reset
  assign WILL_FIRE_RL_strum_reset =
	     vsync && !fretPressed && strumCount != 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_strumCount$write_1__SEL_2 =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ;
  assign MUX_strumCount$write_1__VAL_1 = strumCount + 4'd1 ;

  // register fretPressed
  assign fretPressed$D_IN = x__h569 != 5'd0 ;
  assign fretPressed$EN = vsync ;

  // register fretsDiff
  assign fretsDiff$D_IN = x__h569 != lastFrets ;
  assign fretsDiff$EN = vsync ;

  // register lastFrets
  assign lastFrets$D_IN = x__h569 ;
  assign lastFrets$EN = vsync ;

  // register strumCount
  assign strumCount$D_IN =
	     vsync_pulse_whas_AND_fretPressed_1_2_AND_frets_ETC___d18 ?
	       MUX_strumCount$write_1__VAL_1 :
	       4'd0 ;
  assign strumCount$EN =
	     vsync_pulse_whas_AND_fretPressed_1_2_AND_frets_ETC___d18 ||
	     WILL_FIRE_RL_strum_reset ||
	     WILL_FIRE_RL_strum_off ;

  // register strumOutput
  assign strumOutput$D_IN = !MUX_strumCount$write_1__SEL_2 ;
  assign strumOutput$EN =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ||
	     vsync_pulse_whas_AND_fretPressed_1_2_AND_frets_ETC___d18 ;

  // remaining internal signals
  assign vsync_pulse_whas_AND_fretPressed_1_2_AND_frets_ETC___d18 =
	     vsync && fretPressed && fretsDiff && strumCount < strumTime_in ;
  assign x__h569 = { fret_g, fret_r, fret_y, fret_b, fret_o } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        fretPressed <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fretsDiff <= `BSV_ASSIGNMENT_DELAY 1'd0;
	lastFrets <= `BSV_ASSIGNMENT_DELAY 5'd0;
	strumCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	strumOutput <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (fretPressed$EN)
	  fretPressed <= `BSV_ASSIGNMENT_DELAY fretPressed$D_IN;
	if (fretsDiff$EN) fretsDiff <= `BSV_ASSIGNMENT_DELAY fretsDiff$D_IN;
	if (lastFrets$EN) lastFrets <= `BSV_ASSIGNMENT_DELAY lastFrets$D_IN;
	if (strumCount$EN)
	  strumCount <= `BSV_ASSIGNMENT_DELAY strumCount$D_IN;
	if (strumOutput$EN)
	  strumOutput <= `BSV_ASSIGNMENT_DELAY strumOutput$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fretPressed = 1'h0;
    fretsDiff = 1'h0;
    lastFrets = 5'h0A;
    strumCount = 4'hA;
    strumOutput = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkStrum

