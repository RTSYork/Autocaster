//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Thu Feb 28 16:27:18 GMT 2013
//
// Method conflict info:
// Method: move
// Sequenced before (restricted): move
// Sequenced after (restricted): out
//
// Method: out
// Conflict-free: out
// Sequenced before (restricted): move
//
//
// Ports:
// Name                         I/O  size props
// out                            O     8 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// move_enabled                   I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkWhammy(CLK,
		RST_N,

		move_enabled,

		out);
  input  CLK;
  input  RST_N;

  // action method move
  input  move_enabled;

  // value method out
  output [7 : 0] out;

  // signals for module outputs
  wire [7 : 0] out;

  // register down
  reg down;
  wire down$D_IN, down$EN;

  // register moving
  reg moving;
  wire moving$D_IN, moving$EN;

  // register value
  reg [23 : 0] value;
  reg [23 : 0] value$D_IN;
  wire value$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_count;

  // inputs to muxes for submodule ports
  wire [23 : 0] MUX_value$write_1__VAL_1,
		MUX_value$write_1__VAL_2,
		MUX_value$write_1__VAL_3;

  // value method out
  assign out = value[23:16] ;

  // rule RL_count
  assign WILL_FIRE_RL_count =
	     value != 24'd0 && value != 24'hFFFFFF && moving ;

  // inputs to muxes for submodule ports
  assign MUX_value$write_1__VAL_1 = down ? value - 24'd1 : value + 24'd1 ;
  assign MUX_value$write_1__VAL_2 = value + 24'd1 ;
  assign MUX_value$write_1__VAL_3 = value - 24'd1 ;

  // register down
  assign down$D_IN = value != 24'd0 ;
  assign down$EN = value == 24'd0 || value == 24'hFFFFFF ;

  // register moving
  assign moving$D_IN = move_enabled ;
  assign moving$EN = 1'd1 ;

  // register value
  always@(WILL_FIRE_RL_count or
	  MUX_value$write_1__VAL_1 or
	  value or MUX_value$write_1__VAL_2 or MUX_value$write_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_count: value$D_IN = MUX_value$write_1__VAL_1;
      value == 24'd0: value$D_IN = MUX_value$write_1__VAL_2;
      value == 24'hFFFFFF: value$D_IN = MUX_value$write_1__VAL_3;
      default: value$D_IN =
		   24'b101010101010101010101010 /* unspecified value */ ;
    endcase
  end
  assign value$EN =
	     WILL_FIRE_RL_count || value == 24'd0 || value == 24'hFFFFFF ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        down <= `BSV_ASSIGNMENT_DELAY 1'd0;
	moving <= `BSV_ASSIGNMENT_DELAY 1'd0;
	value <= `BSV_ASSIGNMENT_DELAY 24'd0;
      end
    else
      begin
        if (down$EN) down <= `BSV_ASSIGNMENT_DELAY down$D_IN;
	if (moving$EN) moving <= `BSV_ASSIGNMENT_DELAY moving$D_IN;
	if (value$EN) value <= `BSV_ASSIGNMENT_DELAY value$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    down = 1'h0;
    moving = 1'h0;
    value = 24'hAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkWhammy

