//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Mon Apr 15 16:39:12 BST 2013
//
// Method conflict info:
// Method: vsync
// Conflict-free: hsync, vde, press, strum
// Sequenced before (restricted): rgb,
// 			       xPos,
// 			       yPos,
// 			       trigUp,
// 			       trigDown,
// 			       smoothing,
// 			       strumTime
// Conflicts: vsync
//
// Method: hsync
// Conflict-free: vsync,
// 	       vde,
// 	       rgb,
// 	       xPos,
// 	       yPos,
// 	       trigUp,
// 	       trigDown,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Conflicts: hsync
//
// Method: vde
// Conflict-free: vsync,
// 	       hsync,
// 	       rgb,
// 	       xPos,
// 	       yPos,
// 	       trigUp,
// 	       trigDown,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Conflicts: vde
//
// Method: rgb
// Conflict-free: hsync,
// 	       vde,
// 	       xPos,
// 	       yPos,
// 	       trigUp,
// 	       trigDown,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Sequenced before (restricted): rgb
// Sequenced after (restricted): vsync
//
// Method: xPos
// Conflict-free: hsync,
// 	       vde,
// 	       rgb,
// 	       yPos,
// 	       trigUp,
// 	       trigDown,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Sequenced before (restricted): xPos
// Sequenced after (restricted): vsync
//
// Method: yPos
// Conflict-free: hsync,
// 	       vde,
// 	       rgb,
// 	       xPos,
// 	       trigUp,
// 	       trigDown,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Sequenced before (restricted): yPos
// Sequenced after (restricted): vsync
//
// Method: trigUp
// Conflict-free: hsync,
// 	       vde,
// 	       rgb,
// 	       xPos,
// 	       yPos,
// 	       trigDown,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Sequenced before (restricted): trigUp
// Sequenced after (restricted): vsync
//
// Method: trigDown
// Conflict-free: hsync,
// 	       vde,
// 	       rgb,
// 	       xPos,
// 	       yPos,
// 	       trigUp,
// 	       smoothing,
// 	       strumTime,
// 	       press,
// 	       strum
// Sequenced before (restricted): trigDown
// Sequenced after (restricted): vsync
//
// Method: smoothing
// Conflict-free: hsync, vde, rgb, xPos, yPos, trigUp, trigDown, strumTime
// Sequenced before (restricted): smoothing
// Sequenced after (restricted): vsync, press, strum
//
// Method: strumTime
// Conflict-free: hsync, vde, rgb, xPos, yPos, trigUp, trigDown, smoothing, press
// Sequenced before (restricted): strumTime
// Sequenced after (restricted): vsync, strum
//
// Method: press
// Conflict-free: vsync,
// 	       hsync,
// 	       vde,
// 	       rgb,
// 	       xPos,
// 	       yPos,
// 	       trigUp,
// 	       trigDown,
// 	       strumTime,
// 	       press,
// 	       strum
// Sequenced before (restricted): smoothing
//
// Method: strum
// Conflict-free: vsync,
// 	       hsync,
// 	       vde,
// 	       rgb,
// 	       xPos,
// 	       yPos,
// 	       trigUp,
// 	       trigDown,
// 	       press,
// 	       strum
// Sequenced before (restricted): smoothing, strumTime
//
//
// Ports:
// Name                         I/O  size props
// press                          O     1 reg
// strum                          O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// rgb_pixel                      I    24 reg
// xPos_val                       I    11
// yPos_val                       I    10
// trigUp_val                     I    24 reg
// trigDown_val                   I    24 reg
// smoothing_val                  I     4 reg
// strumTime_val                  I     4 reg
// vsync                          I     1
// hsync                          I     1
// vde                            I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkFret(CLK,
	      RST_N,

	      vsync,

	      hsync,

	      vde,

	      rgb_pixel,

	      xPos_val,

	      yPos_val,

	      trigUp_val,

	      trigDown_val,

	      smoothing_val,

	      strumTime_val,

	      press,

	      strum);
  parameter [1 : 0] lOffset = 2'b0;
  parameter [1 : 0] rOffset = 2'b0;
  input  CLK;
  input  RST_N;

  // action method vsync
  input  vsync;

  // action method hsync
  input  hsync;

  // action method vde
  input  vde;

  // action method rgb
  input  [23 : 0] rgb_pixel;

  // action method xPos
  input  [10 : 0] xPos_val;

  // action method yPos
  input  [9 : 0] yPos_val;

  // action method trigUp
  input  [23 : 0] trigUp_val;

  // action method trigDown
  input  [23 : 0] trigDown_val;

  // action method smoothing
  input  [3 : 0] smoothing_val;

  // action method strumTime
  input  [3 : 0] strumTime_val;

  // value method press
  output press;

  // value method strum
  output strum;

  // signals for module outputs
  wire press, strum;

  // register blue
  reg [7 : 0] blue;
  wire [7 : 0] blue$D_IN;
  wire blue$EN;

  // register fretPressed
  reg fretPressed;
  wire fretPressed$D_IN, fretPressed$EN;

  // register fretPressedDly
  reg fretPressedDly;
  wire fretPressedDly$D_IN, fretPressedDly$EN;

  // register fretValue1
  reg fretValue1;
  wire fretValue1$D_IN, fretValue1$EN;

  // register fretValue2
  reg fretValue2;
  wire fretValue2$D_IN, fretValue2$EN;

  // register fretValue3
  reg fretValue3;
  wire fretValue3$D_IN, fretValue3$EN;

  // register green
  reg [7 : 0] green;
  wire [7 : 0] green$D_IN;
  wire green$EN;

  // register pressDelay
  reg [3 : 0] pressDelay;
  wire [3 : 0] pressDelay$D_IN;
  wire pressDelay$EN;

  // register red
  reg [7 : 0] red;
  wire [7 : 0] red$D_IN;
  wire red$EN;

  // register smoothVal
  reg [3 : 0] smoothVal;
  wire [3 : 0] smoothVal$D_IN;
  wire smoothVal$EN;

  // register strumCount
  reg [3 : 0] strumCount;
  reg [3 : 0] strumCount$D_IN;
  wire strumCount$EN;

  // register strumOutput
  reg strumOutput;
  wire strumOutput$D_IN, strumOutput$EN;

  // register strumTimeVal
  reg [3 : 0] strumTimeVal;
  wire [3 : 0] strumTimeVal$D_IN;
  wire strumTimeVal$EN;

  // register trigDownB
  reg [7 : 0] trigDownB;
  wire [7 : 0] trigDownB$D_IN;
  wire trigDownB$EN;

  // register trigDownG
  reg [7 : 0] trigDownG;
  wire [7 : 0] trigDownG$D_IN;
  wire trigDownG$EN;

  // register trigDownR
  reg [7 : 0] trigDownR;
  wire [7 : 0] trigDownR$D_IN;
  wire trigDownR$EN;

  // register trigUpB
  reg [7 : 0] trigUpB;
  wire [7 : 0] trigUpB$D_IN;
  wire trigUpB$EN;

  // register trigUpG
  reg [7 : 0] trigUpG;
  wire [7 : 0] trigUpG$D_IN;
  wire trigUpG$EN;

  // register trigUpR
  reg [7 : 0] trigUpR;
  wire [7 : 0] trigUpR$D_IN;
  wire trigUpR$EN;

  // register x
  reg [10 : 0] x;
  wire [10 : 0] x$D_IN;
  wire x$EN;

  // register xPos1
  reg [10 : 0] xPos1;
  wire [10 : 0] xPos1$D_IN;
  wire xPos1$EN;

  // register xPos2
  reg [10 : 0] xPos2;
  wire [10 : 0] xPos2$D_IN;
  wire xPos2$EN;

  // register xPos3
  reg [10 : 0] xPos3;
  wire [10 : 0] xPos3$D_IN;
  wire xPos3$EN;

  // register y
  reg [9 : 0] y;
  wire [9 : 0] y$D_IN;
  wire y$EN;

  // register yPos1
  reg [9 : 0] yPos1;
  wire [9 : 0] yPos1$D_IN;
  wire yPos1$EN;

  // register yPos2
  reg [9 : 0] yPos2;
  wire [9 : 0] yPos2$D_IN;
  wire yPos2$EN;

  // register yPos3
  reg [9 : 0] yPos3;
  wire [9 : 0] yPos3$D_IN;
  wire yPos3$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_fret_delay_done,
       WILL_FIRE_RL_fret_delay_inc,
       WILL_FIRE_RL_new_line,
       WILL_FIRE_RL_new_pixel,
       WILL_FIRE_RL_start_pixel1,
       WILL_FIRE_RL_start_pixel2,
       WILL_FIRE_RL_start_pixel3,
       WILL_FIRE_RL_strum_off,
       WILL_FIRE_RL_strum_on,
       WILL_FIRE_RL_strum_reset;

  // inputs to muxes for submodule ports
  wire [10 : 0] MUX_x$write_1__VAL_1;
  wire [9 : 0] MUX_y$write_1__VAL_1;
  wire [3 : 0] MUX_pressDelay$write_1__VAL_1,
	       MUX_strumCount$write_1__VAL_1,
	       MUX_strumCount$write_1__VAL_2;
  wire MUX_fretValue1$write_1__VAL_1,
       MUX_fretValue1$write_1__VAL_2,
       MUX_strumOutput$write_1__SEL_1,
       MUX_x$write_1__SEL_2;

  // remaining internal signals
  wire pressDelay_1_EQ_smoothVal_2___d23,
       x_EQ_xPos1_4_5_AND_y_0_EQ_yPos1_6_7_8_AND_NOT__ETC___d49,
       x_EQ_xPos1_4_5_AND_y_0_EQ_yPos1_6_7_8_AND_fret_ETC___d79,
       x_EQ_xPos2_5_6_AND_y_0_EQ_yPos2_7_8_9_AND_NOT__ETC___d70,
       x_EQ_xPos2_5_6_AND_y_0_EQ_yPos2_7_8_9_AND_fret_ETC___d92,
       x_EQ_xPos3_2_3_AND_y_0_EQ_yPos3_4_5_6_AND_NOT__ETC___d77,
       x_EQ_xPos3_2_3_AND_y_0_EQ_yPos3_4_5_6_AND_fret_ETC___d94;

  // value method press
  assign press = fretPressedDly ;

  // value method strum
  assign strum = strumOutput ;

  // rule RL_strum_on
  assign WILL_FIRE_RL_strum_on =
	     vsync && fretPressedDly && strumCount < strumTimeVal ;

  // rule RL_strum_off
  assign WILL_FIRE_RL_strum_off =
	     vsync && fretPressedDly && strumCount == strumTimeVal ;

  // rule RL_fret_delay_inc
  assign WILL_FIRE_RL_fret_delay_inc =
	     !fretPressed && fretPressedDly &&
	     !pressDelay_1_EQ_smoothVal_2___d23 &&
	     vsync ;

  // rule RL_fret_delay_done
  assign WILL_FIRE_RL_fret_delay_done =
	     !fretPressed && fretPressedDly &&
	     pressDelay_1_EQ_smoothVal_2___d23 &&
	     vsync ;

  // rule RL_start_pixel1
  assign WILL_FIRE_RL_start_pixel1 =
	     x_EQ_xPos1_4_5_AND_y_0_EQ_yPos1_6_7_8_AND_NOT__ETC___d49 &&
	     !vsync ;

  // rule RL_start_pixel2
  assign WILL_FIRE_RL_start_pixel2 =
	     x_EQ_xPos2_5_6_AND_y_0_EQ_yPos2_7_8_9_AND_NOT__ETC___d70 &&
	     !vsync ;

  // rule RL_start_pixel3
  assign WILL_FIRE_RL_start_pixel3 =
	     x_EQ_xPos3_2_3_AND_y_0_EQ_yPos3_4_5_6_AND_NOT__ETC___d77 &&
	     !vsync ;

  // rule RL_new_line
  assign WILL_FIRE_RL_new_line = hsync && !vsync && x != 11'd0 ;

  // rule RL_new_pixel
  assign WILL_FIRE_RL_new_pixel = vde && !hsync && !vsync ;

  // rule RL_strum_reset
  assign WILL_FIRE_RL_strum_reset =
	     vsync && !fretPressedDly && strumCount != 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_strumOutput$write_1__SEL_1 =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ;
  assign MUX_x$write_1__SEL_2 = WILL_FIRE_RL_new_line || vsync ;
  assign MUX_fretValue1$write_1__VAL_1 =
	     red >= trigUpR && green >= trigUpG && blue >= trigUpB ;
  assign MUX_fretValue1$write_1__VAL_2 =
	     red >= trigDownR || green >= trigDownG || blue >= trigDownB ;
  assign MUX_pressDelay$write_1__VAL_1 = pressDelay + 4'd1 ;
  assign MUX_strumCount$write_1__VAL_1 = strumCount + 4'd1 ;
  assign MUX_strumCount$write_1__VAL_2 = strumTimeVal + 4'd1 ;
  assign MUX_x$write_1__VAL_1 = x + 11'd1 ;
  assign MUX_y$write_1__VAL_1 = y + 10'd1 ;

  // register blue
  assign blue$D_IN = rgb_pixel[7:0] ;
  assign blue$EN = 1'd1 ;

  // register fretPressed
  assign fretPressed$D_IN = fretValue2 ;
  assign fretPressed$EN = vsync ;

  // register fretPressedDly
  assign fretPressedDly$D_IN = !WILL_FIRE_RL_fret_delay_done ;
  assign fretPressedDly$EN = WILL_FIRE_RL_fret_delay_done || fretPressed ;

  // register fretValue1
  assign fretValue1$D_IN =
	     WILL_FIRE_RL_start_pixel1 ?
	       MUX_fretValue1$write_1__VAL_1 :
	       MUX_fretValue1$write_1__VAL_2 ;
  assign fretValue1$EN =
	     WILL_FIRE_RL_start_pixel1 ||
	     x_EQ_xPos1_4_5_AND_y_0_EQ_yPos1_6_7_8_AND_fret_ETC___d79 &&
	     !vsync ;

  // register fretValue2
  assign fretValue2$D_IN =
	     WILL_FIRE_RL_start_pixel2 ?
	       MUX_fretValue1$write_1__VAL_1 :
	       MUX_fretValue1$write_1__VAL_2 ;
  assign fretValue2$EN =
	     WILL_FIRE_RL_start_pixel2 ||
	     x_EQ_xPos2_5_6_AND_y_0_EQ_yPos2_7_8_9_AND_fret_ETC___d92 &&
	     !vsync ;

  // register fretValue3
  assign fretValue3$D_IN =
	     WILL_FIRE_RL_start_pixel3 ?
	       MUX_fretValue1$write_1__VAL_1 :
	       MUX_fretValue1$write_1__VAL_2 ;
  assign fretValue3$EN =
	     WILL_FIRE_RL_start_pixel3 ||
	     x_EQ_xPos3_2_3_AND_y_0_EQ_yPos3_4_5_6_AND_fret_ETC___d94 &&
	     !vsync ;

  // register green
  assign green$D_IN = rgb_pixel[15:8] ;
  assign green$EN = 1'd1 ;

  // register pressDelay
  assign pressDelay$D_IN =
	     WILL_FIRE_RL_fret_delay_inc ?
	       MUX_pressDelay$write_1__VAL_1 :
	       4'd0 ;
  assign pressDelay$EN =
	     WILL_FIRE_RL_fret_delay_inc || WILL_FIRE_RL_fret_delay_done ;

  // register red
  assign red$D_IN = rgb_pixel[23:16] ;
  assign red$EN = 1'd1 ;

  // register smoothVal
  assign smoothVal$D_IN = smoothing_val ;
  assign smoothVal$EN = 1'd1 ;

  // register strumCount
  always@(WILL_FIRE_RL_strum_on or
	  MUX_strumCount$write_1__VAL_1 or
	  WILL_FIRE_RL_strum_off or
	  MUX_strumCount$write_1__VAL_2 or WILL_FIRE_RL_strum_reset)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_strum_on: strumCount$D_IN = MUX_strumCount$write_1__VAL_1;
      WILL_FIRE_RL_strum_off: strumCount$D_IN = MUX_strumCount$write_1__VAL_2;
      WILL_FIRE_RL_strum_reset: strumCount$D_IN = 4'd0;
      default: strumCount$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign strumCount$EN =
	     WILL_FIRE_RL_strum_on || WILL_FIRE_RL_strum_off ||
	     WILL_FIRE_RL_strum_reset ;

  // register strumOutput
  assign strumOutput$D_IN = !MUX_strumOutput$write_1__SEL_1 ;
  assign strumOutput$EN =
	     WILL_FIRE_RL_strum_reset || WILL_FIRE_RL_strum_off ||
	     WILL_FIRE_RL_strum_on ;

  // register strumTimeVal
  assign strumTimeVal$D_IN = strumTime_val ;
  assign strumTimeVal$EN = 1'd1 ;

  // register trigDownB
  assign trigDownB$D_IN = trigDown_val[7:0] ;
  assign trigDownB$EN = 1'd1 ;

  // register trigDownG
  assign trigDownG$D_IN = trigDown_val[15:8] ;
  assign trigDownG$EN = 1'd1 ;

  // register trigDownR
  assign trigDownR$D_IN = trigDown_val[23:16] ;
  assign trigDownR$EN = 1'd1 ;

  // register trigUpB
  assign trigUpB$D_IN = trigUp_val[7:0] ;
  assign trigUpB$EN = 1'd1 ;

  // register trigUpG
  assign trigUpG$D_IN = trigUp_val[15:8] ;
  assign trigUpG$EN = 1'd1 ;

  // register trigUpR
  assign trigUpR$D_IN = trigUp_val[23:16] ;
  assign trigUpR$EN = 1'd1 ;

  // register x
  assign x$D_IN = WILL_FIRE_RL_new_pixel ? MUX_x$write_1__VAL_1 : 11'd0 ;
  assign x$EN = WILL_FIRE_RL_new_pixel || WILL_FIRE_RL_new_line || vsync ;

  // register xPos1
  assign xPos1$D_IN = xPos_val - 11'd15 ;
  assign xPos1$EN = 1'd1 ;

  // register xPos2
  assign xPos2$D_IN = xPos_val + 11'd1 ;
  assign xPos2$EN = 1'd1 ;

  // register xPos3
  assign xPos3$D_IN = xPos_val + 11'd17 ;
  assign xPos3$EN = 1'd1 ;

  // register y
  assign y$D_IN = WILL_FIRE_RL_new_line ? MUX_y$write_1__VAL_1 : 10'd0 ;
  assign y$EN = MUX_x$write_1__SEL_2 ;

  // register yPos1
  assign yPos1$D_IN = yPos_val + { 8'd0, lOffset } - 10'd1 ;
  assign yPos1$EN = 1'd1 ;

  // register yPos2
  assign yPos2$D_IN = yPos_val ;
  assign yPos2$EN = 1'd1 ;

  // register yPos3
  assign yPos3$D_IN = yPos_val + { 8'd0, rOffset } - 10'd1 ;
  assign yPos3$EN = 1'd1 ;

  // remaining internal signals
  assign pressDelay_1_EQ_smoothVal_2___d23 = pressDelay == smoothVal ;
  assign x_EQ_xPos1_4_5_AND_y_0_EQ_yPos1_6_7_8_AND_NOT__ETC___d49 =
	     x == xPos1 && y == yPos1 && !fretPressed ;
  assign x_EQ_xPos1_4_5_AND_y_0_EQ_yPos1_6_7_8_AND_fret_ETC___d79 =
	     x == xPos1 && y == yPos1 && fretPressed ;
  assign x_EQ_xPos2_5_6_AND_y_0_EQ_yPos2_7_8_9_AND_NOT__ETC___d70 =
	     x == xPos2 && y == yPos2 && !fretPressed ;
  assign x_EQ_xPos2_5_6_AND_y_0_EQ_yPos2_7_8_9_AND_fret_ETC___d92 =
	     x == xPos2 && y == yPos2 && fretPressed ;
  assign x_EQ_xPos3_2_3_AND_y_0_EQ_yPos3_4_5_6_AND_NOT__ETC___d77 =
	     x == xPos3 && y == yPos3 && !fretPressed ;
  assign x_EQ_xPos3_2_3_AND_y_0_EQ_yPos3_4_5_6_AND_fret_ETC___d94 =
	     x == xPos3 && y == yPos3 && fretPressed ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        blue <= `BSV_ASSIGNMENT_DELAY 8'd0;
	fretPressed <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fretPressedDly <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fretValue1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fretValue2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	fretValue3 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	green <= `BSV_ASSIGNMENT_DELAY 8'd0;
	pressDelay <= `BSV_ASSIGNMENT_DELAY 4'd0;
	red <= `BSV_ASSIGNMENT_DELAY 8'd0;
	smoothVal <= `BSV_ASSIGNMENT_DELAY 4'd0;
	strumCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	strumOutput <= `BSV_ASSIGNMENT_DELAY 1'd0;
	strumTimeVal <= `BSV_ASSIGNMENT_DELAY 4'd0;
	trigDownB <= `BSV_ASSIGNMENT_DELAY 8'd0;
	trigDownG <= `BSV_ASSIGNMENT_DELAY 8'd0;
	trigDownR <= `BSV_ASSIGNMENT_DELAY 8'd0;
	trigUpB <= `BSV_ASSIGNMENT_DELAY 8'd0;
	trigUpG <= `BSV_ASSIGNMENT_DELAY 8'd0;
	trigUpR <= `BSV_ASSIGNMENT_DELAY 8'd0;
	x <= `BSV_ASSIGNMENT_DELAY 11'd0;
	xPos1 <= `BSV_ASSIGNMENT_DELAY 11'd0;
	xPos2 <= `BSV_ASSIGNMENT_DELAY 11'd0;
	xPos3 <= `BSV_ASSIGNMENT_DELAY 11'd0;
	y <= `BSV_ASSIGNMENT_DELAY 10'd0;
	yPos1 <= `BSV_ASSIGNMENT_DELAY 10'd0;
	yPos2 <= `BSV_ASSIGNMENT_DELAY 10'd0;
	yPos3 <= `BSV_ASSIGNMENT_DELAY 10'd0;
      end
    else
      begin
        if (blue$EN) blue <= `BSV_ASSIGNMENT_DELAY blue$D_IN;
	if (fretPressed$EN)
	  fretPressed <= `BSV_ASSIGNMENT_DELAY fretPressed$D_IN;
	if (fretPressedDly$EN)
	  fretPressedDly <= `BSV_ASSIGNMENT_DELAY fretPressedDly$D_IN;
	if (fretValue1$EN)
	  fretValue1 <= `BSV_ASSIGNMENT_DELAY fretValue1$D_IN;
	if (fretValue2$EN)
	  fretValue2 <= `BSV_ASSIGNMENT_DELAY fretValue2$D_IN;
	if (fretValue3$EN)
	  fretValue3 <= `BSV_ASSIGNMENT_DELAY fretValue3$D_IN;
	if (green$EN) green <= `BSV_ASSIGNMENT_DELAY green$D_IN;
	if (pressDelay$EN)
	  pressDelay <= `BSV_ASSIGNMENT_DELAY pressDelay$D_IN;
	if (red$EN) red <= `BSV_ASSIGNMENT_DELAY red$D_IN;
	if (smoothVal$EN) smoothVal <= `BSV_ASSIGNMENT_DELAY smoothVal$D_IN;
	if (strumCount$EN)
	  strumCount <= `BSV_ASSIGNMENT_DELAY strumCount$D_IN;
	if (strumOutput$EN)
	  strumOutput <= `BSV_ASSIGNMENT_DELAY strumOutput$D_IN;
	if (strumTimeVal$EN)
	  strumTimeVal <= `BSV_ASSIGNMENT_DELAY strumTimeVal$D_IN;
	if (trigDownB$EN) trigDownB <= `BSV_ASSIGNMENT_DELAY trigDownB$D_IN;
	if (trigDownG$EN) trigDownG <= `BSV_ASSIGNMENT_DELAY trigDownG$D_IN;
	if (trigDownR$EN) trigDownR <= `BSV_ASSIGNMENT_DELAY trigDownR$D_IN;
	if (trigUpB$EN) trigUpB <= `BSV_ASSIGNMENT_DELAY trigUpB$D_IN;
	if (trigUpG$EN) trigUpG <= `BSV_ASSIGNMENT_DELAY trigUpG$D_IN;
	if (trigUpR$EN) trigUpR <= `BSV_ASSIGNMENT_DELAY trigUpR$D_IN;
	if (x$EN) x <= `BSV_ASSIGNMENT_DELAY x$D_IN;
	if (xPos1$EN) xPos1 <= `BSV_ASSIGNMENT_DELAY xPos1$D_IN;
	if (xPos2$EN) xPos2 <= `BSV_ASSIGNMENT_DELAY xPos2$D_IN;
	if (xPos3$EN) xPos3 <= `BSV_ASSIGNMENT_DELAY xPos3$D_IN;
	if (y$EN) y <= `BSV_ASSIGNMENT_DELAY y$D_IN;
	if (yPos1$EN) yPos1 <= `BSV_ASSIGNMENT_DELAY yPos1$D_IN;
	if (yPos2$EN) yPos2 <= `BSV_ASSIGNMENT_DELAY yPos2$D_IN;
	if (yPos3$EN) yPos3 <= `BSV_ASSIGNMENT_DELAY yPos3$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    blue = 8'hAA;
    fretPressed = 1'h0;
    fretPressedDly = 1'h0;
    fretValue1 = 1'h0;
    fretValue2 = 1'h0;
    fretValue3 = 1'h0;
    green = 8'hAA;
    pressDelay = 4'hA;
    red = 8'hAA;
    smoothVal = 4'hA;
    strumCount = 4'hA;
    strumOutput = 1'h0;
    strumTimeVal = 4'hA;
    trigDownB = 8'hAA;
    trigDownG = 8'hAA;
    trigDownR = 8'hAA;
    trigUpB = 8'hAA;
    trigUpG = 8'hAA;
    trigUpR = 8'hAA;
    x = 11'h2AA;
    xPos1 = 11'h2AA;
    xPos2 = 11'h2AA;
    xPos3 = 11'h2AA;
    y = 10'h2AA;
    yPos1 = 10'h2AA;
    yPos2 = 10'h2AA;
    yPos3 = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkFret

