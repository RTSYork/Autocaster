//
// Generated by Bluespec Compiler, version 2012.01.A (build 26572, 2012-01-17)
//
// On Fri Aug 30 14:17:20 BST 2013
//
// Method conflict info:
// Method: move
// Sequenced before (restricted): move
// Sequenced after (restricted): out
//
// Method: out
// Conflict-free: out
// Sequenced before (restricted): move
//
//
// Ports:
// Name                         I/O  size props
// out                            O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// move_enabled                   I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
`define BSV_ASSIGNMENT_DELAY
`endif

module mkTilt(CLK,
	      RST_N,

	      move_enabled,

	      out);
  input  CLK;
  input  RST_N;

  // action method move
  input  move_enabled;

  // value method out
  output out;

  // signals for module outputs
  wire out;

  // register high
  reg high;
  wire high$D_IN, high$EN;

  // register highValue
  reg [24 : 0] highValue;
  wire [24 : 0] highValue$D_IN;
  wire highValue$EN;

  // register lowValue
  reg [28 : 0] lowValue;
  wire [28 : 0] lowValue$D_IN;
  wire lowValue$EN;

  // register moving
  reg moving;
  wire moving$D_IN, moving$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_highCount,
       WILL_FIRE_RL_highTop,
       WILL_FIRE_RL_lowCount,
       WILL_FIRE_RL_lowTop;

  // inputs to muxes for submodule ports
  wire [28 : 0] MUX_lowValue$write_1__VAL_1;
  wire [24 : 0] MUX_highValue$write_1__VAL_1;

  // value method out
  assign out = high && moving ;

  // rule RL_lowCount
  assign WILL_FIRE_RL_lowCount = moving && !high && lowValue != 29'h1FFFFFFF ;

  // rule RL_highCount
  assign WILL_FIRE_RL_highCount = moving && high && highValue != 25'h1FFFFFF ;

  // rule RL_lowTop
  assign WILL_FIRE_RL_lowTop = moving && !high && lowValue == 29'h1FFFFFFF ;

  // rule RL_highTop
  assign WILL_FIRE_RL_highTop = moving && high && highValue == 25'h1FFFFFF ;

  // inputs to muxes for submodule ports
  assign MUX_highValue$write_1__VAL_1 = highValue + 25'd1 ;
  assign MUX_lowValue$write_1__VAL_1 = lowValue + 29'd1 ;

  // register high
  assign high$D_IN = !WILL_FIRE_RL_highTop ;
  assign high$EN = WILL_FIRE_RL_highTop || WILL_FIRE_RL_lowTop ;

  // register highValue
  assign highValue$D_IN =
	     WILL_FIRE_RL_highCount ? MUX_highValue$write_1__VAL_1 : 25'd0 ;
  assign highValue$EN = WILL_FIRE_RL_highCount || WILL_FIRE_RL_highTop ;

  // register lowValue
  assign lowValue$D_IN =
	     WILL_FIRE_RL_lowCount ? MUX_lowValue$write_1__VAL_1 : 29'd0 ;
  assign lowValue$EN = WILL_FIRE_RL_lowCount || WILL_FIRE_RL_lowTop ;

  // register moving
  assign moving$D_IN = move_enabled ;
  assign moving$EN = 1'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!RST_N)
      begin
        high <= `BSV_ASSIGNMENT_DELAY 1'd0;
	highValue <= `BSV_ASSIGNMENT_DELAY 25'd0;
	lowValue <= `BSV_ASSIGNMENT_DELAY 29'd0;
	moving <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (high$EN) high <= `BSV_ASSIGNMENT_DELAY high$D_IN;
	if (highValue$EN) highValue <= `BSV_ASSIGNMENT_DELAY highValue$D_IN;
	if (lowValue$EN) lowValue <= `BSV_ASSIGNMENT_DELAY lowValue$D_IN;
	if (moving$EN) moving <= `BSV_ASSIGNMENT_DELAY moving$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    high = 1'h0;
    highValue = 25'h0AAAAAA;
    lowValue = 29'h0AAAAAAA;
    moving = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkTilt

